
<script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><div id="icosaedro-container" style="width: 100%; height: 100vh;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        
        const container = document.getElementById('icosaedro-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        
        const geometry = new THREE.IcosahedronGeometry(1, 0);
        


        geometry.computeBoundingBox();
        const maxY = geometry.boundingBox.max.y;
        const minY = geometry.boundingBox.min.y;


        const centerY = (maxY + minY) / 2;


        geometry.translate(0, -centerY, 0);


let topVertex = null;
let minDist = Infinity;
for (let i = 0; i < geometry.attributes.position.count; i++) {
    const x = geometry.attributes.position.getX(i);
    const y = geometry.attributes.position.getY(i);
    const z = geometry.attributes.position.getZ(i);
    const dist = Math.sqrt(x * x + (y - (maxY - centerY)) ** 2 + z * z);
    if (dist < minDist) {
        minDist = dist;
        topVertex = new THREE.Vector3(x, y, z);
    }
}


const up = new THREE.Vector3(0, 1, 0);
const axis = new THREE.Vector3().crossVectors(topVertex, up).normalize();
const angle = topVertex.angleTo(up);


geometry.applyMatrix4(new THREE.Matrix4().makeRotationAxis(axis, angle));

        
        const material = new THREE.MeshPhongMaterial({
            color: 0xcfcfcf,
            flatShading: true,
            shininess: 100,
            side: THREE.DoubleSide
        });
        
        const icosaedro = new THREE.Mesh(geometry, material);
        scene.add(icosaedro);

        
        
        

        
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(1, 1, 1);
        scene.add(light1);
        
        const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
        light2.position.set(-1, -1, -1);
        scene.add(light2);
        
        scene.add(new THREE.AmbientLight(0x404040));

        
        camera.position.z = 3;
        camera.position.y = 0.5; 

        
        function animate() {
            requestAnimationFrame(animate);
            
            
            icosaedro.rotation.y += 0.005;
            
            renderer.render(scene, camera);
        }
        animate();

        
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    });
</script>